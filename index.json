[{"content":"はじめに Global Cybersecurity Camp(GCC) 2023 Singaporeが2月13~17日の間に開催されていました。 GCCは人材育成とコミュニティの形成を目的として開催されているイベントです。 GCCについての詳細は公式ページをご覧ください。 今年はなんと2020年ぶりのオンサイト開催なので、選考を通過すると無料で海外に行ける太っ腹イベントになっています。\n今回、選考通過し、イベントを終えて来たので、参加記として後世に残しておこうと思います。\n他の参加者の記事 watasukeさん（弊チームのモデレータさん、お世話になりました🙇） GCC 2023 Singaporeにチューターとして参加しました yu1hpaくん（記事👇でも言及されていますがお話できてとても楽しかったです🙌） GCC 2023 in Singapore 参加記 セキュアスカイ・テクノロジーさん（マンゴスチンをおすそ分けしていただきました。ありがとうございます。美味しかったです😋） GCC 2023 Singapore スポンサー視点参加レポ 参加前 GCCがオンサイトで開催されることを知って応募するか〜と思っていました。 個人情報多めなので応募書類を晒すことはしないですが、研究とかインターンの経験を書いて課題を解いたという感じです。 応募締め切り付近は研究タスクに追われていてかなり参っていたのですが、よく出したと思います1。えらいぞ、自分 😤\n正直受かるとは思っておらず2、選考通過メールが届いたときはびっくりしました3。 受かってからは事前課題（といっても大体は環境構築）をして気づいたら出発前日でした。\n参加中 一部時間が変更になった講義もありますが、大まかなスケジュールはこちらで公開されています。 移動日と講義に分けて簡単に振り返っていきます。\nday0（出国\u0026amp;アイスブレイキングディナー） フライトが羽田発だったのですが、朝が異常に早くつらかったです。 あと早朝の電車なのに死ぬほど人が多かったです。東京怖いですね。 シンガポールまでは7時間ぐらいのフライトでした。\n当然ですがシンガポールに到着してからは気温が高いので、蒸し暑さが新鮮でした。 ホテルにチェックインするぐらいから、英語でサバイブする必要があり、ドキドキしていました。 また、受講生は国籍が異なる2~3人で一部屋となっており、僕の場合は2人部屋だったのでその点もドキドキしていました。 部屋にすでにいるのかな？と思っていたけどまだ到着していないようでした。\nアイスブレイキングディナーは日本チームが到着する頃にはすでに始まっており、ご飯も残り少なく悲しかったです。 とりあえずお酒を飲んで、いろいろな人と話していました。 このときに同じグループメンバーと会えたことや、ルームメイト、お酒好きの子4と話せたのは運が良かったです。\nday1~5（講義） 翌日からは5日間講義メインでした。 講義内容についてはあまり言及できない5のですが、簡単に各講義の感想と講義中の生活についてまとめます。\nIntroduction to Web Pentesting(day1) 一番最初の講義。 Webの基礎からBurp Suiteの使い方、OWASP Juice Shopを使ったCTF形式の実践までを学びました。 CTFと聞くとワクワクする人間なんですが、例にもれず楽しかったです。 OWASP Juice Shopは今まで触ったことがなかったのですが、recon要素が結構あって大変でした。 実際のpentestってCTFと違ってrecon要素があるのは当然なのですが、競技+時間制限があると焦ってしまう。\nHackathon of Powershell Malware Detection Engine(day1, 3) Powershellマルウェアの利点や性質を学んだ後、Powershellマルウェアの検知を行うスクリプトを作成する講義でした。 この講義はグループ内でアイデアを出し実装するので、ディスカッションをするのですが、英語力がなく方向性について議論ができなかったのが悔やまれます。 自分の実力不足によって十分に参加できなかったのは残念ですが、とてもクリエイティブな講義で楽しかったです。 結果としては弊チームは3位でした、チームメンバーがとても優秀でしたね👏。\nReverse Engineering Malware Written in C++ with IDA and Semi-Automated Scripts(day2) C++の基礎（オブジェクト指向周りの話やTemplates, vftableなど）からCTOを使った自動解析などを学びました。 また、実践としてCTF形式でC++製マルウェアの解析も行いました6。 かなり濃い講義で、いかに今まで適当にC++製バイナリを読んでいたか痛感させられました。 正直理解が追いついていない箇所もあったので復習します。\nHypervisor 101 in Rust(day3) この講義では、Fuzzing機能を持つhypervisorをRustで実装し、その周辺技術を学びました。 講義内容については講師のSatoshi Tandaさんによりこちらで公開されています。\nこの講義は事前準備の時点である程度共有されており、この量を5時間でやるの正気か…？と思いとてもビビっていた講義です。 実際、講義の流れとしては必要な機能とそれを実装するための命令について学んだ後、各チェックポイントを実装する流れになっており、本質部分に注力できる形になっていました。 基本的には講義資料とIntel/AMDの仕様書を見ると実装できるのですが、Rustにあまり馴染みがないので少し苦戦しました。 Rustしっかり入門しておくべきでしたね…\n最近Rustを触る機運が高まっているので入門してまたチャレンジしたいです🦀\nPractical Malware and Ransomeware Investigation(day4) どこまで言及して良いのか一番わからない講義です。 いろいろな統計データと共にランサムウェアの脅威について学びました（大雑把に言うとこう？）。 講師の方の都合で講義パートだけで終わってしまったっぽい。\nWeb Tracking and Browser Fingerprinting(day4) Browser Fingerprintingの様々な手法を知り、プライバシー保護の観点からも考察する講義でした。 Browser Fingerprintingについては全然知らなかったのですが、プライバシー保護はどの技術スタックでも難しいトピックだなと感じました。\nDrone Security and Signal Analysis(day4,5) ドローンのセキュリティについて学びました。 信号解析についてはあんまり言及されていなかった気がするんですが僕の英語力がなかっただけですかね？ ただ、ネットワークのパケット解析的なものは少しありました。 また、講師の方がパワフルでとてもおもしろい方だったのでずっと笑ってた気がします。\nこの講義は公開されているスケジュールとは違い、2日間に分かれていました。 1日目は座学で、2日目は実際にドローンを組み立てて飛ばしてみる実践でした。 2日目にはパケット解析をしてもよかったのですが、疲労困憊の僕は脳死でドローンを飛ばしていました。 どろーんとばすの、たのし〜〜〜（実際操作は結構難しいですが…）\nAttacker behavior analysis base on attack vector analysis(day5) Apacheのアクセスログから攻撃者のIPアドレスを見つける講義でした。 Webの基礎からunixコマンドを使ったログの解析方法までを学びました。 5日目の疲れた脳みそにはほどよい講義でした。\n講義中の生活 基本的に朝6時半起き、1~2時頃に就寝という生活をしていてかなりハードでした7。 朝昼晩すべて会場で提供されるので講義中はほとんど会場で過ごしていました。 会場にいなけれいけないということではなく外食してもよいので、時間変更によって空き時間が増えた4日目はいくつかのグループで昼ご飯に出かけたりしました🍴\nまた、ホテルの立地がよく歩いて15分ほどでマーライオンのところまで行けるので、夜そのあたりを観光してからグループワークを夜中までやるといった刺激的な毎日を送っていました。 ただ、毎日夜遅くまでグループワークをしていたというわけでもなく、飲みに行ったりもしてました8 🍺\nday6（観光\u0026amp;帰国） 朝にGCC参加者で観光を少しして朝ご飯なのか昼ご飯なのかわからないご飯を食べた後に日本チームは帰国となります。 5日間ハードなスケジュールを共に過ごしていたのでかなり名残惜しかったです。 たくさん写真をとりました📷\n帰りのフライトは昼食を食べた後爆睡していました。💤\n感想 オンサイトのイベントはやっぱり最高だな〜と思いました。 やっぱりここ数年はオンラインのイベントが多かったので、オンサイトの良さを再実感しました。 雑談を通じて様々な国の文化にふれることができてとても刺激的でした。 セキュリティはCS分野の中でも特に国際的な影響が強く表れるので、いろいろな国籍の人と話せることはとてもよい機会だなと思いました。 あと、参加者各位若くて優秀な人たちばかりでまぶしかったです😇\nまた、これからの課題だと感じたのは英語力です。 Powershellマルウェア検知の講義でも述べたように英語力があれば…というシーンがとてもたくさんありました。 講義時間以外でも楽しく会話できたのですが、もっと細かいニュアンスを伝えたい！とどうしても思ってしまいます。 英語…もっとできるようになりたいです。精進します。\nコミュニティの形成としては皆とてもアグレッシブで様々な媒体でつながりを持つことができました。 Twitterをやってる人があんまりいなかったことが驚きでした。\n今回GCCを通して、まだまだ未熟な点（英語とかコンピュータ何もわかってないこととか）も再確認できたので、これからも精進していこうと思います。\n修了証、想像の5倍はいい紙（謎情報）\n最後に このような機会を用意してくださったGCC運営メンバーや渡航や生活のサポートをしてくださったセキュリティキャンプ関係者の皆さん、ありがとうございました。 また、GCCを通じて関わってくださった皆様にも感謝します🙇\nGCC2024はタイでの開催のようなので、興味がある方は是非挑戦してみてください9。\n無能ゆえ研究に精神をすり減らして精進皆無生活を送りがち…\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n今回の講義メインが低レイヤっぽいのと、セキュリティキャンプ全国大会に参加してない勢なので、このツイートを見て弱気になった\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nyoshi-camp参加中に選考通過メールが届いて驚いた記憶がある\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n終盤この子と片っ端から残っているビールを飲んでいた\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n英語力がないので言及していい部分とだめな部分が正直全部把握してない…\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n何を解いたかとかは言及してはいけなかった記憶があるので、ここでは触れません\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n木曜日には疲労maxでグループメンバーにめっちゃ疲れてるねって言われた\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n結局夜中まで飲み歩くので睡眠時間は😇\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nセキュリティキャンプ全国大会に参加していなくても選考には関係ないようなので、これまでセキュリティキャンプにチャレンジしてこなかった人も是非!\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://y05h1k1ng.github.io/posts/gcc2023-singapore/","summary":"はじめに Global Cybersecurity Camp(GCC) 2023 Singaporeが2月13~17日の間に開催されていました。 GCCは人材育成とコミュニティの形成を目的として開催されているイベントです。 GCCについての詳細は公式ページをご覧ください。 今年はなんと2020年ぶりのオンサイト開催なので、選考を通過すると無料で海外に行ける太っ腹イベントになっています。\n今回、選考通過し、イベントを終えて来たので、参加記として後世に残しておこうと思います。\n他の参加者の記事 watasukeさん（弊チームのモデレータさん、お世話になりました🙇） GCC 2023 Singaporeにチューターとして参加しました yu1hpaくん（記事👇でも言及されていますがお話できてとても楽しかったです🙌） GCC 2023 in Singapore 参加記 セキュアスカイ・テクノロジーさん（マンゴスチンをおすそ分けしていただきました。ありがとうございます。美味しかったです😋） GCC 2023 Singapore スポンサー視点参加レポ 参加前 GCCがオンサイトで開催されることを知って応募するか〜と思っていました。 個人情報多めなので応募書類を晒すことはしないですが、研究とかインターンの経験を書いて課題を解いたという感じです。 応募締め切り付近は研究タスクに追われていてかなり参っていたのですが、よく出したと思います1。えらいぞ、自分 😤\n正直受かるとは思っておらず2、選考通過メールが届いたときはびっくりしました3。 受かってからは事前課題（といっても大体は環境構築）をして気づいたら出発前日でした。\n参加中 一部時間が変更になった講義もありますが、大まかなスケジュールはこちらで公開されています。 移動日と講義に分けて簡単に振り返っていきます。\nday0（出国\u0026amp;アイスブレイキングディナー） フライトが羽田発だったのですが、朝が異常に早くつらかったです。 あと早朝の電車なのに死ぬほど人が多かったです。東京怖いですね。 シンガポールまでは7時間ぐらいのフライトでした。\n当然ですがシンガポールに到着してからは気温が高いので、蒸し暑さが新鮮でした。 ホテルにチェックインするぐらいから、英語でサバイブする必要があり、ドキドキしていました。 また、受講生は国籍が異なる2~3人で一部屋となっており、僕の場合は2人部屋だったのでその点もドキドキしていました。 部屋にすでにいるのかな？と思っていたけどまだ到着していないようでした。\nアイスブレイキングディナーは日本チームが到着する頃にはすでに始まっており、ご飯も残り少なく悲しかったです。 とりあえずお酒を飲んで、いろいろな人と話していました。 このときに同じグループメンバーと会えたことや、ルームメイト、お酒好きの子4と話せたのは運が良かったです。\nday1~5（講義） 翌日からは5日間講義メインでした。 講義内容についてはあまり言及できない5のですが、簡単に各講義の感想と講義中の生活についてまとめます。\nIntroduction to Web Pentesting(day1) 一番最初の講義。 Webの基礎からBurp Suiteの使い方、OWASP Juice Shopを使ったCTF形式の実践までを学びました。 CTFと聞くとワクワクする人間なんですが、例にもれず楽しかったです。 OWASP Juice Shopは今まで触ったことがなかったのですが、recon要素が結構あって大変でした。 実際のpentestってCTFと違ってrecon要素があるのは当然なのですが、競技+時間制限があると焦ってしまう。\nHackathon of Powershell Malware Detection Engine(day1, 3) Powershellマルウェアの利点や性質を学んだ後、Powershellマルウェアの検知を行うスクリプトを作成する講義でした。 この講義はグループ内でアイデアを出し実装するので、ディスカッションをするのですが、英語力がなく方向性について議論ができなかったのが悔やまれます。 自分の実力不足によって十分に参加できなかったのは残念ですが、とてもクリエイティブな講義で楽しかったです。 結果としては弊チームは3位でした、チームメンバーがとても優秀でしたね👏。","title":"Global Cybersecurity Camp 2023 Singapore 参加記"},{"content":"今年もtheoldmoon0602とptr-yudaiと僕の3人でCTFを開催しました。 前年度まではInterKosenCTFという名前で開催していたのですが、今年は名前を変えての開催となりました。\n他の2人の記事\ntheoldmoon0602: https://furutsuki.hatenablog.com/entry/2021/08/29/224254 ptr-yudai: https://ptr-yudai.hatenablog.com/entry/2021/08/30/000015 問題リポジトリ\nhttps://github.com/theoremoon/cakectf-2021-public 作成した問題について [rev] Hash Browns 単純なx64elf解析問題です。 関数fでなにかやってますが、見る人がみるとxgcd()に見えるのかな？と思います。わからなくても動的解析をしたり、デコンパイルしたコードを実装すればなんとかなると思います。 ハッシュが含まれる2つの配列のindexがそれぞれわかれば、ローカルでハッシュ値と合う文字を1文字づつ探索すればフラグが入手できます。 関数fの理解がからっきしだめでもフラグの偶数indexは復元できます。 そこから奇数indexの文字をエスパーするみたいなことができ\u0026hellip;ないです（たぶん）。 フラグを入手された方はわかると思うんですが、フザけたフラグになってるのでエスパーは厳しいと思います。\nreversingの作問は初めてだったのでreversingの問題としての面白さがわからず不安でした。 Surveyを見た感じそれなりに楽しんでもらえたようでほっとしています。 ちなみに問題名のHash Brownsは去年のこのCTF(旧InterKosenCTF)でボツ問になった問題名から取ってきてます。\nwriteup: https://hackmd.io/@ptr-yudai/rJWHh_SwO\n[crypto] Together as one 基礎的な初等整数論の知識で解ける問題です。 この問題はzer0pts CTF 2021を目標に作ってたけど、納得の行くものになったのが開催前日とかでこちらで出題しました。 当初はmediumぐらいで出してたけど、謎のパワーでlunaticになりました。 なんか毎年難易度推定バグってるけど、dynamic scoringだしまぁいっか！（おっとぼけ）という気持ちが自分の中である気がする。 よくないですね。 善処します。\n問題名のTogether as one はTimmy TrumpetのDiamondsから来ています。素数が3つ集まっている感じとか、Together as one っぽくないですか（僕だけ）？\nwriteup: https://hackmd.io/@yoshiking/rJ5suNPXO\n[misc] Break a leg miscのwarmup枠で出した問題です。 authorがtheoldmoon0602と僕になっていますが、これは僕の原案をtheoldmoon0602がいい感じにした結果がこの問題です。 ん〜、まあこれは特にコメントはないです。\n感想 毎年大した仕事もせずに運営面をしているわけですが、今年も例にはもれずプー太郎でした 🐻 。 作問能力も運営能力も他2人の足元にも及ばないことは明らかだけど、それはそれとして今回の準備どうなのって感じだと思います。\n運営中は序盤ではドタバタしながらフラグの修正したりしました。 残りの時間はブラウザで遊べるゲームをみんなでしてました。 大体負けた記憶しかないですが、めちゃくちゃ楽しかったです。 あと、最近失いかけていた関西弁が戻りました。 今はよくわからない言語を話しています。\n最後に参加者の皆様ありがとうございました、お疲れ様です。 また、ポジティブな意見をくださった皆様もありがとうございます。 次回の励みになるので褒めてください 🐶 。 運営の2人もお疲れ様でした。 仕事サボってごめんなさい。\n","permalink":"https://y05h1k1ng.github.io/posts/cakectf-2021/","summary":"今年もtheoldmoon0602とptr-yudaiと僕の3人でCTFを開催しました。 前年度まではInterKosenCTFという名前で開催していたのですが、今年は名前を変えての開催となりました。\n他の2人の記事\ntheoldmoon0602: https://furutsuki.hatenablog.com/entry/2021/08/29/224254 ptr-yudai: https://ptr-yudai.hatenablog.com/entry/2021/08/30/000015 問題リポジトリ\nhttps://github.com/theoremoon/cakectf-2021-public 作成した問題について [rev] Hash Browns 単純なx64elf解析問題です。 関数fでなにかやってますが、見る人がみるとxgcd()に見えるのかな？と思います。わからなくても動的解析をしたり、デコンパイルしたコードを実装すればなんとかなると思います。 ハッシュが含まれる2つの配列のindexがそれぞれわかれば、ローカルでハッシュ値と合う文字を1文字づつ探索すればフラグが入手できます。 関数fの理解がからっきしだめでもフラグの偶数indexは復元できます。 そこから奇数indexの文字をエスパーするみたいなことができ\u0026hellip;ないです（たぶん）。 フラグを入手された方はわかると思うんですが、フザけたフラグになってるのでエスパーは厳しいと思います。\nreversingの作問は初めてだったのでreversingの問題としての面白さがわからず不安でした。 Surveyを見た感じそれなりに楽しんでもらえたようでほっとしています。 ちなみに問題名のHash Brownsは去年のこのCTF(旧InterKosenCTF)でボツ問になった問題名から取ってきてます。\nwriteup: https://hackmd.io/@ptr-yudai/rJWHh_SwO\n[crypto] Together as one 基礎的な初等整数論の知識で解ける問題です。 この問題はzer0pts CTF 2021を目標に作ってたけど、納得の行くものになったのが開催前日とかでこちらで出題しました。 当初はmediumぐらいで出してたけど、謎のパワーでlunaticになりました。 なんか毎年難易度推定バグってるけど、dynamic scoringだしまぁいっか！（おっとぼけ）という気持ちが自分の中である気がする。 よくないですね。 善処します。\n問題名のTogether as one はTimmy TrumpetのDiamondsから来ています。素数が3つ集まっている感じとか、Together as one っぽくないですか（僕だけ）？\nwriteup: https://hackmd.io/@yoshiking/rJ5suNPXO\n[misc] Break a leg miscのwarmup枠で出した問題です。 authorがtheoldmoon0602と僕になっていますが、これは僕の原案をtheoldmoon0602がいい感じにした結果がこの問題です。 ん〜、まあこれは特にコメントはないです。\n感想 毎年大した仕事もせずに運営面をしているわけですが、今年も例にはもれずプー太郎でした 🐻 。 作問能力も運営能力も他2人の足元にも及ばないことは明らかだけど、それはそれとして今回の準備どうなのって感じだと思います。\n運営中は序盤ではドタバタしながらフラグの修正したりしました。 残りの時間はブラウザで遊べるゲームをみんなでしてました。 大体負けた記憶しかないですが、めちゃくちゃ楽しかったです。 あと、最近失いかけていた関西弁が戻りました。 今はよくわからない言語を話しています。\n最後に参加者の皆様ありがとうございました、お疲れ様です。 また、ポジティブな意見をくださった皆様もありがとうございます。 次回の励みになるので褒めてください 🐶 。 運営の2人もお疲れ様でした。 仕事サボってごめんなさい。","title":"CakeCTF 2021 振り返り"},{"content":" ⚠️ Wrteupではなく\u0026quot;参加記\u0026quot;です。読み物としてご覧ください。 書いてみたらそんなことはないかも、いやそうかも？わかんない\nはじめに 一人チーム(UdagawaWhiteBears)で出て、42位2602点でした。 内訳としては、cryptoとrevは全部解き、他ジャンルは簡単な問題をいくつか解きました。\n普通にwriteup書いてもな〜(なんで?)となったので、今回はどのような流れでcryptoを解いていったのか流れを書いていこうと思います。 なんでこんなことをやりだしたかというと、ptr-yudaiが書いたTSG LIVE ! 6 CTFのWriteupが面白かったからです。 あとは、数式を書くのが面倒だからです（ぶっちゃけ）。\n作問者writeupも出ていますし、SECCON Beginnersなので日本人の参加者は多いと思うので、詳細は他の人が書いてくれるでしょうと信じています。 あと、全然理解せずにこいつ解いてるんだな〜みたいな様子が伝わればいいなと思います😇\n開始前 16:00から開始だと思ってたら14:00からで、ちょっと焦った記憶があります（遅刻はしてないけど）。 pwnerと違ってcrytpoでは特に準備することがありません。 わくわくしておけば💯だと思います。\n真面目な話をすると、先述のptr-yudaiの記事ではpythonとsageをまず実行しておくと次に起動するときに早くなるらしいですが、全然知らなかったしやってないです。 まあ誤差でしょう()\n戦略的にはcrypto全部解きたいな〜ぐらいに考えていて、beginner向けなので、難しい問題から手をつけていこうと思っていました。\nはじまりはじまり〜🎉 14:00! はじまり〜〜、わくわくしすぎてワクワクさんになりました。\n早速、問題に取り掛かろうと思うのですが、ファイルのダウンロードができません😢 問題サーバーは生きてるので、ncする問題(Imaginary)があったのでこれを見てみることにしました（難しい問題からやる？そんなことはとうの昔に忘れました）。\n[crypto] Imaginary 接続した感じと問題文で、わぁ〜なんか虚数じゃん、ツラと思います。\n$ nc imaginary.quals.beginners.seccon.jp 1337 Welcome to Secret IMAGINARY NUMBER Store! 1. Save a number 2. Show numbers 3. Import numbers 4. Export numbers 0. Exit \u0026gt; べそをかいていると、ファイルのダウンロードができるようになりました。 さすがLMT、30秒もかかってないんじゃないでしょうか（適当）。\nファイルを見ていきます。\nうえ〜〜、100行以上あるじゃん、ぴえんです。 CTFというのはフラグと呼ばれる文字列を見つけるゲームなので、とりあえずCtrl + sでflagを探してみます(emacs user)。\ndef _secret(self): if \u0026#39;1337i\u0026#39; in self.numbers: self.request.sendall(b\u0026#39;Congratulations!\\n\u0026#39;) self.request.sendall(f\u0026#39;The flag is {flag}\\n\u0026#39;.encode()) いますね。 self.numbersに1337iが含まれていればOKっぽいです。 あとは_secret(self)を呼んでいる箇所を探します。 Ctrl + sで(略)\nelif num == 5: self._secret() ？？？、おまっ？どこから湧いてきたんや！？\n失礼、近所の関西弁のおじさんが出てきてしまいましたが、気にせずにいきましょう。\n接続した際にはいなかった、選択肢がありましたね。 とりあえず、この辺でflagを得る道筋がすこし見えてきました。 今わかっている限りでは、self.numbersに1337iをsaveとかで含めて、5を呼べば良さそうです。\nとりあえず、self.numbersに値を入れたいので、_save()を見に行きます。\ndef _save(self): try: self.request.sendall(b\u0026#39;Real part\u0026gt; \u0026#39;) re = int(self.request.recv(128).strip()) self.request.sendall(b\u0026#39;Imaginary part\u0026gt; \u0026#39;) im = int(self.request.recv(128).strip()) name = f\u0026#39;{re} + {im}i\u0026#39; self.numbers[name] = [re, im] except ValueError: pass なんのcheckも入っていません。 てか、self.numbersが配列かな〜と勝手に推測していたのですが、dictです。 え？これ入れるだけでは？と思って試してみます。\n$ nc imaginary.quals.beginners.seccon.jp 1337 Welcome to Secret IMAGINARY NUMBER Store! 1. Save a number 2. Show numbers 3. Import numbers 4. Export numbers 0. Exit \u0026gt; 1 Real part\u0026gt; 0 Imaginary part\u0026gt; 1337 1. Save a number 2. Show numbers 3. Import numbers 4. Export numbers 0. Exit \u0026gt; 2 -------------------------------------------------- 0 + 1337i: (0, 1337) -------------------------------------------------- う、なるほど、0が入るのね〜とわかります。\nここで、これpythonで hoge in dictって、比較されるのkey?value?と思って確認します。\n$ python3 Python 3.8.5 (default, Jan 27 2021, 15:41:15) [GCC 9.3.0] on linux Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; a = {\u0026#34;x\u0026#34;: 1} \u0026gt;\u0026gt;\u0026gt; \u0026#34;x\u0026#34; in a True \u0026gt;\u0026gt;\u0026gt; 1 in a False \u0026gt;\u0026gt;\u0026gt; 御意。 さっきやった実験では、0 + 1337iがkeyに入っているので、これではダメそうです。\nまだ、_save()を見ただけなので、もう一つ値を入れれそうな_import()を見ます。\ndef _import(self): self.request.sendall(b\u0026#39;Exported String\u0026gt; \u0026#39;) data = self.request.recv(1024).strip().decode() enc = bytes.fromhex(data) cipher = AES.new(key, AES.MODE_ECB) plaintext = unpad(cipher.decrypt(enc), AES.block_size) self.numbers = json.loads(plaintext.decode()) self.request.sendall(b\u0026#39;Imported.\\n\u0026#39;) self._show() AESの文字がちらつきます。 cryptoになってきました。 虚数から数学問の可能性がありましたが、そうではなさそうです。 与えた文字列をAESのECBモードで復号してから、self.numberにjson.dumpしたものを代入しています。 ECBモードなので、まぁ、なんかできるでしょう！という気持ちになります。\n残るは_exportを見ていきます（_show()には申し訳ないが、スルーさせてもらう）。\ndef _export(self): cipher = AES.new(key, AES.MODE_ECB) dump = pad(json.dumps(self.numbers).encode(), AES.block_size) self.request.sendall(dump + b\u0026#39;\\n\u0026#39;) enc = cipher.encrypt(dump) self.request.sendall(b\u0026#39;Exported:\\n\u0026#39;) self.request.sendall(enc.hex().encode() + b\u0026#39;\\n\u0026#39;) こちらも、特に変わったことはしてなくて、self.numberを文字列にして暗号化したものがもらえます。\nここで、ECBモードなので、\u0026ldquo;いい感じ\u0026quot;にブロックを分けて作ってから、がっちゃんこすればOKみたいな方針が立ちます。ECBモードだと、基本的には同じ平文は同じ暗号文になることを使いがちムーブをしていきます。\nさて、どうやるといい感じになるかな〜と手元で試してみます。\nfrom json import dumps def gen_blocks(s): return [s[i:i+16] for i in range(0, len(s), 16)] x = {\u0026#34;-100 + 1000i\u0026#34;: [-100, 1000], \u0026#34;0 + 1337i\u0026#34;: [0, 1337]} s = dumps(x) blocks = gen_blocks(s) for block in blocks: print(block) $ python3 test.py {\u0026#34;-100 + 1000i\u0026#34;: [-100, 1000], \u0026#34; 0 + 1337i\u0026#34;: [0, 1337]} なんで、マイナスとかつけちゃってるの？という気もしますが、つけたい気分だったんでしょう。 わかりません。\n...], \u0026quot;と1337i\u0026quot;:...をがっちゃんこすれば...],　\u0026quot;1337i\u0026quot;:...となり、良さそうですね。 あとは、1337i\u0026quot;:...から始まるブロックを調整して作って、後ろの2ブロックを使えば、念願のフラグゲットです。\nsaveで、{\u0026quot;-100 + 1000i\u0026quot;: [-100, 1000], \u0026quot;0 + 1337i\u0026quot;: [0, 1337]}となるように値を入れます。 これを、exportして前の2ブロックを使います。 一度、接続を切ってから、次はx = {\u0026quot;10 + 1000i\u0026quot;: [10, 1000], \u0026quot;0 + 1337i\u0026quot;: [0, 1337]}となるようにsaveしていきます。 また、exportして次は後ろの2ブロックを使って、前の2ブロックと今回の後ろ2ブロックをつなげたhex値をimportします。 これで隠し選択肢5を選択すれば、フラグゲットです🚩\nctf4b{yeah_you_are_a_member_of_imaginary_number_club}\nたぶん、30分前後で解けたと思います。 記憶が正しければfirst bloodを頂いていたはずですが、今回のスコアサーバーでは解いた問題の情報が見れないので真相は闇の中\u0026hellip;\nここまで書いてきましたが、普通にWriteupを書くより大変ということに気づいて泣いています。 解法の詳細は他の人に譲って、考えてることを軽く書こうとしてたら、試行錯誤付きのwriteupになってしまって大変疲労しています。 ここからは、解法の詳細は他の人、と復唱しながら書いていきます。\n[crypto] p-8RSA 気を取り直して、次こそは一番むずかしい問題に取り組みます。\nファイルを落としてきます。 問題名からRSAであることは自明ですが、簡単な問題であることを祈ります🙏\nばっと見た感じ暗号化は普通のRSAで、素数の生成が特殊なようです。 qを生成した後、pの生成はqから8を引いていって素数になるまで回してそうです。\nお！これはpとqの差がそこまでなさそうという気持ちになるので、fermat法とかで素因数分解できそうです。 fermat法のスクリプトもってねーと思ったので、google先生にsage fermat factorizationと聞いてみると、いい感じのコードが乗っているサイトを見つけました。 コピって、ペってします。\nyoshiking@yoshiking-vm:~/ctf/seccon_begginers/p-8RSA$ sage ┌────────────────────────────────────────────────────────────────────┐ │ SageMath version 9.2, Release Date: 2020-10-24 │ │ Using Python 3.8.5. Type \u0026#34;help()\u0026#34; for help. │ └────────────────────────────────────────────────────────────────────┘ sage: n = 1692217701880003415077640053307690427052236117123084244791201925961363188187081357161572555509365632685003108528944898394703205166453173384730181508859979770089258399395605909244353802395195544 ....: 75266121835753044660177349444503693993991253475530436734034224314165897550185719665717183285653938232013807360458249 ....: e = 17 ....: c = 1002331319313602783327343416523045558140944872521511317352860746165554027951907976470018896694722907709258390131313562125744552746904221132780155717506533655129986694531619553020085990299191012 ....: 44702933443124944274359143831492874463245444294673660944786888148517110942002726017336219552279179125115273728023902 ....: sage: def fermatfactor(N): ....: if N \u0026lt;= 0: return [N] ....: if is_even(N): return [2,N/2] ....: a = ceil(sqrt(N)) ....: while not is_square(a^2-N): ....: a = a + 1 ....: b = sqrt(a^2-N) ....: return [a - b,a + b] ....: sage: fermatfactor(n) [13008526826201356667891590694678121516071641430494347349438757349219893000439927852950504383765791466428599814640460028507882213264934492728368742844727189, 13008526826201356667891590694678121516071641430494347349438757349219893000439927852950504383765791466428599814640460028507882213264934492728368742844741541] わいわい\nできてそうですね。 あとは、復号するだけじゃん〜〜と思っていたんですが、素数生成時にpが素数になるまでと他にも条件がありました\u0026hellip;\nif isPrime(p) and GCD(phi, e) != 1: break GCD(phi, e) != 1はツラ\nといっても、よくあることなのでがんばります。\n片方の素数は $(p-1)\\nmid e$だったので、pでニセd作って復号できんじゃね？と思ったら、しっかりとパディングされていました。ぴえん。\nflag = flag.encode(\u0026#34;utf-8\u0026#34;) + urandom(64) のこる手札は、GCD(phi, e)で割ってやる方法ですが、これもGCD(phi, e) = 17なので、ぴえんこえてぱおん。\nもう手札0だよ〜〜ぴえんぴえんとしていると、ある記事を思い出します(bookmarkにあった)。\n中国語の記事だけど、よくまとまってると思います。 https://0xdktb.top/2020/02/28/Summary-of-Crypto-in-CTF-RSA/\nここに乗ってなかったかな〜と思うと、ありました！！ ばんざい🙌\nここでもコピってペっとすればOKと言いたいところですが、記事に乗っている方法は$(p-1) | e$ かつ $(q-1) | e$なので少々オーバーキルです。 そのあたりのスクリプトをいい感じに修正してやると、フラグゲットです。\nfrom binascii import unhexlify from Crypto.Util.number import * def rthroot(c, r, q): c %= q assert(isPrime(r) and (q - 1) % r == 0 and (q - 1) % (r**2) != 0) l = ((q - 1) % (r**2)) // r alpha = (-inverse(l, r)) % r root = pow(c, ((1 + alpha * (q - 1) // r) // r), q) return root def allroot(r, q, root): all_root = set() all_root.add(root) while len(all_root) \u0026lt; r: new_root = root unity = pow(getRandomRange(2, q), (q - 1) // r, q) for i in range(r - 1): new_root = (new_root * unity) % q all_root.add(new_root) return all_root def crt(ai, mi): a1, m1 = ai[0], mi[0] a2, m2 = ai[1], mi[1] return (a1 * inverse(m2, m1) * m2 + a2 * inverse(m1, m2) * m1) % (m1 * m2) def decrypt(proot, qroot, p, q): count = 0 total = len(proot) * len(qroot) t1 = inverse(q, p) t2 = inverse(p, q) for i in proot: for j in qroot: count += 1 root = (i, j) m = crt(root, (p, q)) m = (i * t1 * q + j * t2 * p) % (p * q) flag = long_to_bytes(m) if flag.startswith(b\u0026#34;ctf\u0026#34;): print(\u0026#39;\\n\u0026#39;, flag) def main(): p = 13008526826201356667891590694678121516071641430494347349438757349219893000439927852950504383765791466428599814640460028507882213264934492728368742844727189 q = 13008526826201356667891590694678121516071641430494347349438757349219893000439927852950504383765791466428599814640460028507882213264934492728368742844741541 n = 169221770188000341507764005330769042705223611712308424479120192596136318818708135716157255550936563268500310852894489839470320516645317338473018150885997977008925839939560590924435380239519554475266121835753044660177349444503693993991253475530436734034224314165897550185719665717183285653938232013807360458249 e = 17 c = 100233131931360278332734341652304555814094487252151131735286074616555402795190797647001889669472290770925839013131356212574455274690422113278015571750653365512998669453161955302008599029919101244702933443124944274359143831492874463245444294673660944786888148517110942002726017336219552279179125115273728023902 print(\u0026#39;[+] Calculating e-th root...\u0026#39;) proot = rthroot(c, e, p) #qroot = rthroot(c, e, q) print(\u0026#39;[+] Calculating all e-th roots...\u0026#39;) all_proot = allroot(e, p, proot) #all_qroot = allroot(e, q, qroot) d_ = inverse(e, q-1) all_qroot = {pow(c, d_, q)} print(\u0026#39;[+] CRT cracking...\u0026#39;) decrypt(all_proot, all_qroot, p, q) if __name__ == \u0026#39;__main__\u0026#39;: main() ctf4b{4r3_y0u_up5id3_d0wn?_Fr0m_6310w?_0r_60th?}\n何もわからずに解いてるが、解ければOK\n想定解のカーマイケルの定理、全然頭になかったので、へ〜ってなりました。 手札が増えたので、とりあえずおけまろ水産🐟\nこれも30分前後で解いた気がする。 わかりません。 （書くのは詳細をだいぶ省いたのですぐ書けた、このくらいの気持ちで書いていかないと疲れちゃうよ〜、writeup書く人類全員えらすぎる）\n[crypto] Field_trip 次はこれを取り組んでいきました。\n配布ファイルを見た感じ、ソースコードcipherの生成はここでやっていることがわかります。\ncipher = sum([int(flag[i]) * pub_key[i] for i in range(length)]) output.txtにはpub_keyが入っていたので、LLLでよく見るやつやんけ！！と思ってsolverを書きます（ただ、このときはまだflag[i]が1byteだと思っている）。\nflag[i]を1bytesだと勘違いしているので、雑に書いたら全然違う値が出てきて？？？となりました。 てか、なんか行列のサイズでかくね？？ みたいな違和感から、もうちょっと問題ファイルを見ると、\nflag = bin(flag)[2:] がありました。ぴえん。早とちり早男と申します。\n完全にknapsack暗号ですね。 昔に同じような問題を解いていたので、前ブログの記事からsolverを引っ張り出してきます。 厳密には、密度によっては失敗するかもしれないですが、それでもまだ手札はあったのでとりあえずこのsolverで試してみます。\nfrom sage.all import * from binascii import unhexlify exec(open(\u0026#34;output.txt\u0026#34;).read()) pk = pub_key c = cipher def create_matrix(c, pk): n = len(pk) i = matrix.identity(n) * 2 last_col = [-1]*n first_row = [] for p in pk: first_row.append(p) first_row.append(-c) m = matrix(ZZ, 1, n+1, first_row) m = 1000 * m bottom = i.augment(matrix(ZZ, n, 1, last_col)) m = m.stack(bottom) return m def find_short_vector(matrix): for col in matrix.columns(): if col[0] != 0: continue if is_short_vector(col): return col def is_short_vector(vector): for v in vector: if v != 1 and v != -1 and v != 0: return False return True m = create_matrix(c, pk) lllm = m.transpose().LLL().transpose() short_vector = find_short_vector(lllm) solution_vector = [] for v in short_vector: if v == 1: solution_vector.append(1) elif v == -1: solution_vector.append(0) m = \u0026#34;\u0026#34;.join(map(str, solution_vector)) print(unhexlify(hex(int(m, 2))[2:])) .py\u0026ldquo;でsageを書くのにハマってる時代＆sageに外部パッケージを入れる方法を知らない時代のスクリプトで懐かしくなりました。 今はもう外部パッケージも使えますし、sageは.sageで書きますが、気にせずに実行します。\n$ sage knapsack.sage b\u0026#39;ctf4b{Y35!_I_ju5t_n33d3d_th353_num63r5!}\u0026#39; 💪 🚩 💪\n20分くらい？で解いた？わかんない\nここまで、解ければ後は消化試合という感じですね。 ラストスパートやっていきましょう。\n[crypto] GFM なんか行列がちゃがちゃしてるな〜という所感\nkeyとencはもらえてるっぽいので、これ普通に逆行列計算してやればMでるな〜とわかります。 あとは、Mをいろいろやっているところを見ていきます。\nM = copy(MS.zero()) for i in range(SIZE): for j in range(SIZE): n = i * SIZE + j if n \u0026lt; len(FLAG): M[i, j] = FLAG[n] else: M[i, j] = GF(p).random_element() M行列の要素の初めの方はflagが1文字づつはいってることがわかります。 keyも逆行列を持つことが保証されているので、解けそう。 sageにいれたら、簡単に解けるでしょ〜〜と思ったら、output.txtの出力が空白くぎりで必殺技\u0026quot;コピってペ\u0026quot;ができないです。 これは試合終了かと思われましたが、yoshiking選手、なんとか持ちこたえて修正していきました。\np = 331941721759386740446055265418196301559 SIZE = 8 MS = MatrixSpace(GF(p), SIZE) key = [[116401981595413622233973439379928029316,198484395131713718904460590157431383741,210254590341158275155666088591861364763,63363928577909853981431532626692827712,85569529885869484584091358025414174710,149985744539791485007500878301645174953,257210132141810272397357205004383952828,184416684170101286497942970370929735721], [42252147300048722312776731465252376713,199389697784043521236349156255232274966,310381139154247583447362894923363190365,275829263070032604189578502497555966953,292320824376999192958281274988868304895,324921185626193898653263976562484937554,22686717162639254526255826052697393472,214359781769812072321753087702746129144], [211396100900282889480535670184972456058,210886344415694355400093466459574370742,186128182857385981551625460291114850318,13624871690241067814493032554025486106,255739890982289281987567847525614569368,134368979399364142708704178059411420318,277933069920652939075272826105665044075,61427573037868265485473537350981407215], [282725280056297471271813862105110111601, 183133899330619127259299349651040866360, 275965964963191627114681536924910494932,290264213613308908413657414549659883232,140491946080825343356483570739103790896,115945320124815235263392576250349309769,240154953119196334314982419578825033800, 33183533431462037262108359622963646719], [53797381941014407784987148858765520206, 136359308345749561387923094784792612816, 26225195574024986849888325702082920826,262047729451988373970843409716956598743,170482654414447157611638420335396499834,270894666257247100850080625998081047879, 91361079178051929124422796293638533509, 34320536938591553179352522156012709152], [266361407811039627958670918210300057324, 40603082064365173791090924799619398850, 253357188908081828561984991424432114534, 322939245175391203579369607678957356656, 63315415224740483660852444003806482951, 224451355249970249493628425010262408466, 80574507596932581147177946123110074284, 135660472191299636620089835364724566497],[147031054061160640084051220440591645233, 286143152686211719101923153591621514114, 330366815640573974797084150543488528130, 144943808947651161283902116225593922999, 205798118501774672701619077143286382731, 317326656225121941341827388220018201533, 14319175936916841467976601008623679266, 112709661623759566156255015500851204670],[306746575224464214911885995766809188593, 35156534122767743923667417474200538878, 35608800809152761271316580867239668942, 259728427797578488375863755690441758142, 29823482469997458858051644485250558639, 137507773879704381525141121774823729991, 29893063272339035080311541822496817623, 292327683738678589950939775184752636265]] enc = [[133156758362160693874249080602263044484, 293052519705504374237314478781574255411, 72149359944851514746901936133544542235, 56884023532130350649269153560305458687, 67693140194970657150958369664873936730, 227562364727203645742246559359263307899, 98490363636066788474326997841084979092, 323336812987530088571937131837711189774],[244725074927901230757605861090949184139, 63515536426726760809658259528128105864, 297175420762447340692787685976316634653, 279269959863745528135624660183844601533, 203893759503830977666718848163034645395, 163047775389856094351865609811169485260, 103694284536703795013187648629904551283, 322381436721457334707426033205713602738],[ 17450567396702585206498315474651164931, 105594468721844292976534833206893170749, 10757192948155933023940228740097574294, 132150825033376621961227714966632294973, 329990437240515073537637876706291805678, 57236499879418458740541896196911064438, 265417446675313880790999752931267955356, 73326674854571685938542290353559382428],[270340230065315856318168332917483593198, 217815152309418487303753027816544751231, 55738850736330060752843300854983855505, 236064119692146789532532278818003671413, 104963107909414684818161043267471013832, 234439803801976616706759524848279829319, 173296466130000392237506831379251781235, 34841816336429947760241770816424911200],[140341979141710030301381984850572416509, 248997512418753861458272855046627447638, 58382380514192982462591686716543036965, 188097853050327328682574670122723990784, 125356457137904871005571726686232857387, 55692122688357412528950240580072267902, 21322427002782861702906398261504812439, 97855599554699774346719832323235463339],[298368319184145017709393597751160602769, 311011298046021018241748692366798498529, 165888963658945943429480232453040964455, 240099237723525827201004876223575456211, 306939673050020405511805882694537774846, 7035607106089764511604627683661079229, 198278981512146990284619915272219052007, 255750707476361671578970680702422436637],[ 45315424384273600868106606292238082349, 22526147579041711876519945055798051695, 15778025992115319312591851693766890019, 318446611756066795522259881812628512448, 269954638404267367913546070681612869355, 205423708248276366495211174184786418791, 92563824983279921050396256326760929563, 209843107530597179583072730783030298674],[ 662653811932836620608984350667151180, 304181885849319274230319044357612000272, 280045476178732891877948766225904840517, 216340293591880460916317821948025035163, 79726526647684009633247003110463447210, 36010610538790393011235704307570914178, 284067290617158853279270464803256026349, 45816877317461535723616457939953776625]] C = matrix(enc) K = matrix(key) inv_K = K.inverse() M = inv_K * C * inv_K print([bytes([i%p]) for i in list(M)[0]]) flag = b\u0026#34;\u0026#34; for row in list(M): for x in list(row): x = x % p if 0 \u0026lt;= x \u0026lt;= 255: flag += bytes([x]) else: flag += b\u0026#34;?\u0026#34; print(flag) ctf4b{d1d_y0u_pl4y_w1th_m4tr1x_4nd_g4l0is_f1eld?}\n出力形式がぴえんこえてぱおん🐘\n[crypto] Logical_SEESAW 複数回、同じ鍵でflagとandを取っていることがわかります。 andなので、flagがもともの0の箇所は鍵が何であれ0になります。 また、flagが1の場合は、鍵が0の場合は出力が2通りになり、鍵が1の場合は確率によらす1となります。\nこれを使えば、解けそうです （なんか普通のwriteupになってきましたね、非常に疲れてきました、あと簡単な問題は試行錯誤もないので\u0026hellip;許してください\u0026hellip;）\nimport collections exec(open(\u0026#34;output.txt\u0026#34;).read()) length = len(cipher[0]) flag = \u0026#34;\u0026#34; for i in range(length): bits = [c[i] for c in cipher] cnt = collections.Counter(bits) if len(cnt) == 2: flag += \u0026#34;1\u0026#34; else: flag += cnt.most_common()[0][0] flag = int(flag, 2) print(bytes.fromhex(hex(flag)[2:])) ctf4b{Sh3_54w_4_SEESAW,_5h3_54id_50}\n[crypto] simple_RSA のこりcrypto一問です、最後の有終の美を飾るのはsimpleなRSA問題でした。\nビット長からわかるように、flagをe乗してもnより大きくなっていなさそうです。 square rootを取れば終わりです！\nOK!sagemath!\n$ sage ┌────────────────────────────────────────────────────────────────────┐ │ SageMath version 9.2, Release Date: 2020-10-24 │ │ Using Python 3.8.5. Type \u0026#34;help()\u0026#34; for help. │ └────────────────────────────────────────────────────────────────────┘ sage: n = 1768667184240039357473051203420012852133691956973597279167660505628677847323071842695850887894263158470481734230495929306050761407480055367057903339967904133486315690203093489519767754314220211 ....: 07816294944514533513969621373774114778994925558309827014496925615941751626235809874531513284088501164540581623702737363560683196485671055124528937368669392002970716029942882582952317511179914081605 ....: 69998347640357251625243671483903597718500241970108698224998200840245865354411520826506950733058870602392209113565367230443261205476636664049066621093558272244061778795051583920491406620090704660526 ....: 753969180791952189324046618283 ....: e = 3 ....: c = 2137917515300171115086910841683630246868780573379713198802569241853937371507043427250428414885473159259719603892304533323193718760929680325131490239762871586989902516402983608765893308108131992 ....: 60879441426084508864252450551111064068694725939412142626401778628362399359107132506177231354040057205570428678822068599327926328920350319336256613 ....: output.txtからパラメータペっとして、nth_root()を使えば\u0026hellip;\nsage: m = c.nth_root(e) sage: bytes.fromhex(hex(m)[2:]) b\u0026#34;ctf4b{0,1,10,11...It\u0026#39;s_so_annoying.___I\u0026#39;m_done}\u0026#34; うお〜〜〜〜終わった！！！！！\nRTA: 約2h00m00s 正確なタイムはわかりませんが、16:00にはツイートしてたので、2時間かからないぐらいでしょうか。\nたぶんこの記事を書くほうが時間かかっています。 完全にImaginaryで燃え尽きていますね。 なんでこんな記事書いてるんだろって何度も思いました。\nおわりに やっべ〜〜、魔女のお茶会に遅刻する〜〜〜\n","permalink":"https://y05h1k1ng.github.io/posts/seccon-beginners-2021/","summary":"⚠️ Wrteupではなく\u0026quot;参加記\u0026quot;です。読み物としてご覧ください。 書いてみたらそんなことはないかも、いやそうかも？わかんない\nはじめに 一人チーム(UdagawaWhiteBears)で出て、42位2602点でした。 内訳としては、cryptoとrevは全部解き、他ジャンルは簡単な問題をいくつか解きました。\n普通にwriteup書いてもな〜(なんで?)となったので、今回はどのような流れでcryptoを解いていったのか流れを書いていこうと思います。 なんでこんなことをやりだしたかというと、ptr-yudaiが書いたTSG LIVE ! 6 CTFのWriteupが面白かったからです。 あとは、数式を書くのが面倒だからです（ぶっちゃけ）。\n作問者writeupも出ていますし、SECCON Beginnersなので日本人の参加者は多いと思うので、詳細は他の人が書いてくれるでしょうと信じています。 あと、全然理解せずにこいつ解いてるんだな〜みたいな様子が伝わればいいなと思います😇\n開始前 16:00から開始だと思ってたら14:00からで、ちょっと焦った記憶があります（遅刻はしてないけど）。 pwnerと違ってcrytpoでは特に準備することがありません。 わくわくしておけば💯だと思います。\n真面目な話をすると、先述のptr-yudaiの記事ではpythonとsageをまず実行しておくと次に起動するときに早くなるらしいですが、全然知らなかったしやってないです。 まあ誤差でしょう()\n戦略的にはcrypto全部解きたいな〜ぐらいに考えていて、beginner向けなので、難しい問題から手をつけていこうと思っていました。\nはじまりはじまり〜🎉 14:00! はじまり〜〜、わくわくしすぎてワクワクさんになりました。\n早速、問題に取り掛かろうと思うのですが、ファイルのダウンロードができません😢 問題サーバーは生きてるので、ncする問題(Imaginary)があったのでこれを見てみることにしました（難しい問題からやる？そんなことはとうの昔に忘れました）。\n[crypto] Imaginary 接続した感じと問題文で、わぁ〜なんか虚数じゃん、ツラと思います。\n$ nc imaginary.quals.beginners.seccon.jp 1337 Welcome to Secret IMAGINARY NUMBER Store! 1. Save a number 2. Show numbers 3. Import numbers 4. Export numbers 0. Exit \u0026gt; べそをかいていると、ファイルのダウンロードができるようになりました。 さすがLMT、30秒もかかってないんじゃないでしょうか（適当）。\nファイルを見ていきます。\nうえ〜〜、100行以上あるじゃん、ぴえんです。 CTFというのはフラグと呼ばれる文字列を見つけるゲームなので、とりあえずCtrl + sでflagを探してみます(emacs user)。\ndef _secret(self): if \u0026#39;1337i\u0026#39; in self.","title":"SECCON Beginners CTF 2021 参加記"},{"content":"はじめまして。\n以前はhatena blogに記事の投稿をしていましたが、github pageを使ってみることにしました。 理由としては、hatena blogでのtex記法があまり書きやすくなかったとか、go言語触り始めたぐらいでhugoの存在を知ってなんとなく、というただの好奇心です。\n今使用しているテーマ(PaperMod)はダークモード対応でさらに英語と日本語で記事を分けられて気に入っています。 普段英語で書くことないんですけどね…\n","permalink":"https://y05h1k1ng.github.io/posts/hello_world/","summary":"はじめまして。\n以前はhatena blogに記事の投稿をしていましたが、github pageを使ってみることにしました。 理由としては、hatena blogでのtex記法があまり書きやすくなかったとか、go言語触り始めたぐらいでhugoの存在を知ってなんとなく、というただの好奇心です。\n今使用しているテーマ(PaperMod)はダークモード対応でさらに英語と日本語で記事を分けられて気に入っています。 普段英語で書くことないんですけどね…","title":"Hello World"},{"content":" 学生 CTFがすき CTF 今まで出題した問題\n[crypto] ochazuke | InterKosenCTF 2020 問題ファイル: https://github.com/theoremoon/InterKosenCTF2020-challenges/tree/master/crypto/ochazuke/distfiles [misc] No pressure | InterKosenCTF 2020 問題ファイル: https://github.com/theoremoon/InterKosenCTF2020-challenges/tree/master/misc/no_pressure/distfiles [crypto] dirty laundry | zer0ptsCTF 2020 問題ファイル: https://gitlab.com/zer0pts/zer0pts-ctf-2020/-/tree/master/dirty%20laundry/distfiles 公式Writeup: https://hackmd.io/@yoshiking/H1cUTRfSU CTFtime Writeup: https://ctftime.org/task/10647 [crypto] pascal homomorphicity | InterKosenCTF 2019 問題ファイル: https://github.com/theoremoon/InterKosenCTF2019-challenges-public/tree/master/pascal_homomorphicity/distfiles 公式Writeup: https://hackmd.io/@ptr-yudai/HyxEIwTGr [forensics] Hugtto! | InterKosenCTF 2019 問題ファイル: https://github.com/theoremoon/InterKosenCTF2019-challenges-public/tree/master/hugtto!/distarchive 公式Writeup: https://hackmd.io/@ptr-yudai/SyU0sifXH Links Github: @y05h1k1ng Twitter: @y05h1k1ng Hatena Blog: https://yoshiking.hatenablog.jp/ CTFtime: yoshiking ","permalink":"https://y05h1k1ng.github.io/about.html","summary":" 学生 CTFがすき CTF 今まで出題した問題\n[crypto] ochazuke | InterKosenCTF 2020 問題ファイル: https://github.com/theoremoon/InterKosenCTF2020-challenges/tree/master/crypto/ochazuke/distfiles [misc] No pressure | InterKosenCTF 2020 問題ファイル: https://github.com/theoremoon/InterKosenCTF2020-challenges/tree/master/misc/no_pressure/distfiles [crypto] dirty laundry | zer0ptsCTF 2020 問題ファイル: https://gitlab.com/zer0pts/zer0pts-ctf-2020/-/tree/master/dirty%20laundry/distfiles 公式Writeup: https://hackmd.io/@yoshiking/H1cUTRfSU CTFtime Writeup: https://ctftime.org/task/10647 [crypto] pascal homomorphicity | InterKosenCTF 2019 問題ファイル: https://github.com/theoremoon/InterKosenCTF2019-challenges-public/tree/master/pascal_homomorphicity/distfiles 公式Writeup: https://hackmd.io/@ptr-yudai/HyxEIwTGr [forensics] Hugtto! | InterKosenCTF 2019 問題ファイル: https://github.com/theoremoon/InterKosenCTF2019-challenges-public/tree/master/hugtto!/distarchive 公式Writeup: https://hackmd.io/@ptr-yudai/SyU0sifXH Links Github: @y05h1k1ng Twitter: @y05h1k1ng Hatena Blog: https://yoshiking.hatenablog.jp/ CTFtime: yoshiking ","title":"About me"}]